/* -*-C-*-
 *
 * Copyright (c) 1996 Advanced RISC Machines Limited
 * All Rights Reserved
 *
 * $Revision: 1.29.2.1 $
 *   $Author: rivimey $
 *     $Date: 1998/09/22 13:46:35 $
 *
 * makelo.c - This file is part of the Angel build world. It is used
 * to construct the assembler manifests source file. This ensures that
 * we only need to maintain a single copy of important definitions,
 * with this program being used to automatically build the target
 * header, if the 'C' source headers change.
 *
 * It is unfortunate that we need to keep this file up-to-date by
 * hand. However, the assembler values will always match the 'C'
 * definitions... and the build will fail if a definition required by
 * assembler code has not been added to this file.
 */

#include <stdio.h>
#include <time.h>
#include <errno.h>

/* The following are the Angel headers from which we take information: */
#include "angel.h"
#include "devconf.h"
#include "adp.h"
#include "arm.h"
#include "devices.h"
#include "serlock.h"
#include "pid.h"
#include "serial.h"
#include "support.h"
#include "logging.h"

#define maxstring       (256)

int main(int argc, char **argv)
{
  time_t     tval = time(NULL);   /* seconds since "January 1st 1970 GMT" */
  struct tm *timeptr;             /* full time structure */
  FILE      *outfile = stdout;    /* in-case we want to add code to write
                                   * to a specified file */
  char       buffer[maxstring];   /* temporary string construction buffer */
  char      *tptr;                /* temporary string pointer */
  int        index;               /* general index counter */

  timeptr = gmtime(&tval);

  /*
   * some sanity checks on configuration parameters
   */
  if (DE_NUM_INT_HANDLERS != IH_NUM_DEVICES)
  {
      fprintf(stderr,
              "ERROR: DE_NUM_INT_HANDLERS (%d) != IH_NUM_DEVICES (%d)\n",
              DE_NUM_INT_HANDLERS, IH_NUM_DEVICES);

      return 1;
  }

  /* Check for a command line parameter, and if so, use as the output file */
  if (argc > 1) 
  {
      if ((outfile = fopen(argv[1], "w")) <= (FILE *)0)
          outfile = stdout;
  }

  /*
   * output the file header
   */
  fprintf(outfile, "\tTTL Automatically generated by \"%s\"\n",argv[0]);
  fprintf(outfile, "\t; Do not edit this file directly. Changes made to the 'C' header\n");
  fprintf(outfile, "\t; files will force this file to be re-built by the make process.\n");
  fprintf(outfile, "\tASSERT\t(listopts_s)\t; ensure listopt.s included\n");
  fprintf(outfile, "old_opt\tSETA\t{OPT}\n");
  fprintf(outfile, "\tOPT\t(opt_off)\n\n");

  fprintf(outfile, "\t\tGBLL\tlolevel_s\n");
  fprintf(outfile, "lolevel_s\tSETL\t{TRUE}\n\n");

  /*
   * We provide time and date information, in-case the developer wants
   * to embed identification information into the lo-level assembler
   * code:
   */
  fprintf(outfile, "\t; Time and Date variables\n");
  fprintf(outfile, "\tGBLA\tMakeTime\t; secs since 1st Jan 1970\n");
  fprintf(outfile, "\tGBLS\tMakeDate\t; full ANSI time and date\n");
  fprintf(outfile, "\tGBLS\tMakeDay\t\t; full weekday name\n");
  fprintf(outfile, "\tGBLS\tMakeMDay\t; month day\n");

  fprintf(outfile, "\tGBLS\tMakeMonth\t; full month name\n");
  fprintf(outfile, "\tGBLS\tMakeYear\t; full year number\n");
  fprintf(outfile, "\tGBLS\tMakeClock\t; 24hour clock\n\n");

  fprintf(outfile, "MakeTime\tSETA\t&%08X\n", tval);

  sprintf(buffer, "%s", ctime(&tval));

  for (tptr = buffer; (*tptr && (*tptr != '\n')); tptr++)
    /* do nothing */
    ;

  *tptr = '\0'; /* replace newline with NULL */
  fprintf(outfile, "MakeDate\tSETS\t\"%s\"\n", buffer);

  index = strftime(buffer, maxstring, "%A", timeptr);
  buffer[index] = '\0';
  fprintf(outfile, "MakeDay\t\tSETS\t\"%s\"\n", buffer);

  index = strftime(buffer, maxstring, "%d", timeptr);
  buffer[index] = '\0';
  fprintf(outfile, "MakeMDay\tSETS\t\"%s\"\n", buffer);

  index = strftime(buffer, maxstring, "%B", timeptr);
  buffer[index] = '\0';
  fprintf(outfile, "MakeMonth\tSETS\t\"%s\"\n", buffer);

  index = strftime(buffer, maxstring, "%Y", timeptr);
  buffer[index] = '\0';
  fprintf(outfile, "MakeYear\tSETS\t\"%s\"\n", buffer);

  index = strftime(buffer, maxstring, "%H:%M", timeptr);
  buffer[index] = '\0';
  fprintf(outfile, "MakeClock\tSETS\t\"%s\"\n", buffer);

  /* Standard ARM definitions */
  fprintf(outfile, "\n\t; Standard ARM definitions\n");
  fprintf(outfile, "reg_a1\tRN\t%d\n", reg_a1);
  fprintf(outfile, "reg_a2\tRN\t%d\n", reg_a2);
  fprintf(outfile, "reg_a3\tRN\t%d\n", reg_a3);
  fprintf(outfile, "reg_a4\tRN\t%d\n", reg_a4);
  fprintf(outfile, "reg_v1\tRN\t%d\n", reg_v1);
  fprintf(outfile, "reg_v2\tRN\t%d\n", reg_v2);
  fprintf(outfile, "reg_v3\tRN\t%d\n", reg_v3);
  fprintf(outfile, "reg_v4\tRN\t%d\n", reg_v4);
  fprintf(outfile, "reg_v5\tRN\t%d\n", reg_v5);
  fprintf(outfile, "reg_v6\tRN\t%d\n", reg_v6);
  fprintf(outfile, "reg_sl\tRN\t%d\n", reg_sl);
  fprintf(outfile, "reg_fp\tRN\t%d\n", reg_fp);
  fprintf(outfile, "reg_ip\tRN\t%d\n", reg_ip);
  fprintf(outfile, "reg_sp\tRN\t%d\n", reg_sp);
  fprintf(outfile, "reg_lr\tRN\t%d\n", reg_lr);
  fprintf(outfile, "reg_pc\tRN\t%d\n", reg_pc);
  fprintf(outfile, "reg_sb\tRN\t%d\n", reg_sb);

  fprintf(outfile, "\nIRQDisable\t\tEQU\t0x%08X\n", IRQDisable);
  fprintf(outfile, "FIQDisable\t\tEQU\t0x%08X\n", FIQDisable);
  fprintf(outfile, "InterruptMask\t\tEQU\t0x%08X\n", InterruptMask);
  fprintf(outfile, "ModeMask\t\tEQU\t0x%08X\n", ModeMask);
  fprintf(outfile, "ModeMaskUFIS\t\tEQU\t0x%08X\n", ModeMaskUFIS);
  fprintf(outfile, "USRmode\t\t\tEQU\t0x%08X\n", USRmode);
  fprintf(outfile, "SYSmode\t\t\tEQU\t0x%08X\n", SYSmode);
  fprintf(outfile, "SVCmode\t\t\tEQU\t0x%08X\n", SVCmode);
  fprintf(outfile, "IRQmode\t\t\tEQU\t0x%08X\n", IRQmode);
  fprintf(outfile, "FIQmode\t\t\tEQU\t0x%08X\n", FIQmode);
  fprintf(outfile, "ABTmode\t\t\tEQU\t0x%08X\n", ABTmode);
  fprintf(outfile, "UNDmode\t\t\tEQU\t0x%08X\n", UNDmode);
  fprintf(outfile, "USR26mode\t\tEQU\t0x%08X\n", USR26mode);
  fprintf(outfile, "IRQ26mode\t\tEQU\t0x%08X\n", IRQ26mode);
  fprintf(outfile, "SVC26mode\t\tEQU\t0x%08X\n", SVC26mode);
  fprintf(outfile, "cond_EQ\t\t\tEQU\t0x%08X\n", cond_EQ);
  fprintf(outfile, "cond_mask\t\tEQU\t0x%08X\n", cond_mask);
  fprintf(outfile, "Tbit\t\t\tEQU\t0x%08X\n\n", Tbit);

  fprintf(outfile, "vec_reset\t\t\tEQU\t0x%08X\n", vec_reset);
  fprintf(outfile, "vec_undefined_instruction\tEQU\t0x%08X\n",
          vec_undefined_instruction);
  fprintf(outfile, "vec_SWI\t\t\t\tEQU\t0x%08X\n", vec_SWI);
  fprintf(outfile, "vec_prefetch_abort\t\tEQU\t0x%08X\n", vec_prefetch_abort);
  fprintf(outfile, "vec_data_abort\t\t\tEQU\t0x%08X\n", vec_data_abort);
  fprintf(outfile, "vec_unused\t\t\tEQU\t0x%08X\n", vec_unused);
  fprintf(outfile, "vec_IRQ\t\t\t\tEQU\t0x%08X\n", vec_IRQ);
  fprintf(outfile, "vec_FIQ\t\t\t\tEQU\t0x%08X\n", vec_FIQ);

  fprintf(outfile, "\nangel_BreakPointInstruction_ARM\t\tEQU\t0x%08X\n",
          angel_BreakPointInstruction_ARM);
  fprintf(outfile, "angel_BreakPointInstruction_THUMB\tEQU\t0x%08X\n",
          angel_BreakPointInstruction_THUMB);
  fprintf(outfile, "angel_SWI_ARM\t\t\t\tEQU\t0x%08X\n", angel_SWI_ARM);
  fprintf(outfile, "angel_SWI_THUMB\t\t\t\tEQU\t0x%08X\n", angel_SWI_THUMB);
  fprintf(outfile, "angel_SWIreason_CLibBase\t\tEQU\t0x%08X\n",
          angel_SWIreason_CLibBase);
  fprintf(outfile, "angel_SWIreason_CLibLimit\t\tEQU\t0x%08X\n",
          angel_SWIreason_CLibLimit);
  fprintf(outfile, "angel_SWIreasonLimit\t\t\tEQU\t0x%08X\n",
          angel_SWIreasonLimit);
  fprintf(outfile, "angel_SWIreason_EnterSVC\t\tEQU\t0x%08X\n",
          angel_SWIreason_EnterSVC);
  fprintf(outfile, "angel_SWIreason_ReportException\t\tEQU\t0x%08X\n",
          angel_SWIreason_ReportException);
  fprintf(outfile, "angel_SWIreason_ApplDevice\t\tEQU\t0x%08X\n",
          angel_SWIreason_ApplDevice);
  fprintf(outfile, "angel_SWIreason_LateStartup\t\tEQU\t0x%08X\n",
          angel_SWIreason_LateStartup);

  fprintf(outfile, "angel_SWIreason_SysElapsed\t\tEQU\t0x%08X\n",
          SYS_ELAPSED);
  fprintf(outfile, "angel_SWIreason_SysTickFreq\t\tEQU\t0x%08X\n",
          SYS_TICKFREQ);

  fprintf(outfile, "AL_CONTINUE\t\tEQU\t0x%08X\n", AL_CONTINUE);
  fprintf(outfile, "AL_BLOCK\t\tEQU\t0x%08X\n", AL_BLOCK);

  /* Debug DRAM Area defines for Assembler */

  fprintf(outfile, "DEBUG_BASE\t\tEQU\t0x%08X\n", DEBUG_BASE);
  fprintf(outfile, "DEBUG_SIZE\t\tEQU\t0x%08X\n", DEBUG_SIZE);

  fprintf(outfile, "BRANCH_TO_HIGH_ROM_ON_RESET\t\tEQU\t0x%08X\n",
          BRANCH_TO_HIGH_ROM_ON_RESET);

  fprintf(outfile, "Angel_RegBlockSize\t\tEQU\t0x%08X\n",  sizeof(angel_RegBlock));
  fprintf(outfile, "RB_NumRegblocks\t\t\tEQU\t0x%08X\n", RB_NumRegblocks);

  
  fprintf(outfile, "AngelInterruptMask\t\t\tEQU\t0x%08X\n", AngelInterruptMask);
  fprintf(outfile, "NotAngelInterruptMask\t\t\tEQU\t0x%08X\n", NotAngelInterruptMask);
  
  {
      angel_TaskQueueItem* tqi = 0;
      
      fprintf(outfile, "TQI_Type\t\t\tEQU\t%8d\n", (int)(& (tqi->type))  );
      fprintf(outfile, "TQI_Priority\t\t\tEQU\t%8d\n", (int)(& (tqi->priority))  );
      fprintf(outfile, "TQI_Name\t\tEQU\t%8d\n", (int)(& (tqi->name))  );
      fprintf(outfile, "TQI_SignalWaiting\t\tEQU\t%8d\n", (int)(& (tqi->signalWaiting))  );
      fprintf(outfile, "TQI_State\t\tEQU\t%8d\n", (int)(& (tqi->state))  );
      fprintf(outfile, "TQI_RB\t\tEQU\t%8d\n", (int)(& (tqi->rb))  );
  }
  fprintf(outfile, "TS_Undefined\t\t\tEQU\t0x%08X\n", (int)TS_Undefined);
  fprintf(outfile, "TS_Defined\t\t\tEQU\t0x%08X\n", (int)TS_Defined);
  fprintf(outfile, "TS_Runnable\t\t\tEQU\t0x%08X\n", (int)TS_Runnable);
  fprintf(outfile, "TS_Running\t\tEQU\t0x%08X\n", (int)TS_Running);
  fprintf(outfile, "TS_Blocked\t\tEQU\t0x%08X\n", (int)TS_Blocked);

  fprintf(outfile, "LOG_SERLASM\t\t\tEQU\t0x%08X\n", (int)LOG_SERLASM);
  fprintf(outfile, "LOG_EXCEPT\t\t\tEQU\t0x%08X\n", (int)LOG_EXCEPT);

  /* regblock array indexes */
  fprintf(outfile, "RB_Interrupted\t\t\tEQU\t0x%08X\n", (int)RB_Interrupted);
  fprintf(outfile, "RB_Desired\t\t\tEQU\t0x%08X\n", (int)RB_Desired);
  fprintf(outfile, "RB_SWI\t\t\t\tEQU\t0x%08X\n", (int)RB_SWI);
  fprintf(outfile, "RB_UNDEF\t\t\tEQU\t0x%08X\n", (int)RB_UNDEF);
  fprintf(outfile, "RB_ABORT\t\t\t\tEQU\t0x%08X\n", (int)RB_ABORT);
  fprintf(outfile, "RB_Yield\t\t\tEQU\t0x%08X\n", (int)RB_Yield);
#if DEBUG == 1
  fprintf(outfile, "RB_Fatal\t\t\tEQU\t0x%08X\n", (int)RB_Fatal);
#endif

  /* task priorities */
  fprintf(outfile, "TP_AngelInit\t\t\tEQU\t0x%08X\n", (int)TP_AngelInit);
  fprintf(outfile, "TP_Application\t\t\tEQU\t0x%08X\n", (int)TP_Application);
  fprintf(outfile, "TP_ApplCallBack\t\t\tEQU\t0x%08X\n", (int)TP_ApplCallBack);
  fprintf(outfile, "TP_AngelCallBack\t\tEQU\t0x%08X\n", (int)TP_AngelCallBack);
  fprintf(outfile, "TP_AngelWantLock\t\tEQU\t0x%08X\n", (int)TP_AngelWantLock);

  fprintf(outfile, "arm_padding\t\t\tEQU\t0x%08X\n", arm_padding);

  fprintf(outfile, "\nMMUCP\t\t\tCP\t%d\n", MMUCP);
  fprintf(outfile, "MMUIDReg\t\tCN\t%d\n", MMUIDReg);
  fprintf(outfile, "MMUControlReg\t\tCN\t%d\n", MMUControlReg);
  fprintf(outfile, "MMUPageTableBaseReg\tCN\t%d\n", MMUPageTableBaseReg);
  fprintf(outfile, "MMUDomainAccessReg\tCN\t%d\n", MMUDomainAccessReg);
  fprintf(outfile, "MMUFlushTLBReg\t\tCN\t%d\n", MMUFlushTLBReg);
  fprintf(outfile, "MMUPurgeTLBReg\t\tCN\t%d\n", MMUPurgeTLBReg);
  fprintf(outfile, "MMUFlushIDCeg\t\tCN\t%d\n", MMUFlushIDCReg);
  fprintf(outfile, "\nMMUOn\t\t\tEQU\t0x%08X\n", MMUOn);
  fprintf(outfile, "AlignFaultOn\t\tEQU\t0x%08X\n", AlignFaultOn);
  fprintf(outfile, "CacheOn\t\t\tEQU\t0x%08X\n", CacheOn);
  fprintf(outfile, "WriteBufferOn\t\tEQU\t0x%08X\n", WriteBufferOn);
  fprintf(outfile, "Config32\t\tEQU\t0x%08X\n", Config32);
  fprintf(outfile, "ConfigBE\t\tEQU\t0x%08X\n", ConfigBE);
  fprintf(outfile, "DefaultMMUConfig\tEQU\t0x%08X\n", DefaultMMUConfig);

  fprintf(outfile, "\n\t; ARM identification manifests:\n");
  fprintf(outfile, "ID_unknown\t\tEQU\t0x%08X\n", ID_unknown);
  fprintf(outfile, "ID_ARM1\t\t\tEQU\t0x%08X\n", ID_ARM1);
  fprintf(outfile, "ID_ARM2\t\t\tEQU\t0x%08X\n", ID_ARM2);
  fprintf(outfile, "ID_ARM3\t\t\tEQU\t0x%08X\n", ID_ARM3);
  fprintf(outfile, "ID_ARM6\t\t\tEQU\t0x%08X\n", ID_ARM6);
  fprintf(outfile, "ID_TYPE_MASK\t\tEQU\t0x%08X\n", ID_TYPE_MASK);
  fprintf(outfile, "ID_LE\t\t\tEQU\t0x%08X\n", ID_LE);
  fprintf(outfile, "ID_BE\t\t\tEQU\t0x%08X\n", ID_BE);
  fprintf(outfile, "ID_MUL\t\t\tEQU\t0x%08X\n", ID_MUL);
  fprintf(outfile, "ID_SWP\t\t\tEQU\t0x%08X\n", ID_SWP);
  fprintf(outfile, "ID_CACHE\t\tEQU\t0x%08X\n", ID_CACHE);
  fprintf(outfile, "ID_MMU\t\t\tEQU\t0x%08X\n", ID_MMU);
  fprintf(outfile, "ID_ENDIAN\t\tEQU\t0x%08X\n", ID_ENDIAN);
  fprintf(outfile, "ID_CACHE_ON\t\tEQU\t0x%08X\n", ID_CACHE_ON);
  fprintf(outfile, "ID_WB_ON\t\tEQU\t0x%08X\n", ID_WB_ON);
  fprintf(outfile, "ID_HWCONFIG_MASK\tEQU\t0x%08X\n", ID_HWCONFIG_MASK);

  /* Angel memory information: */
  fprintf(outfile, "\n\t; Angel memory information:\n");
  {
    fprintf(outfile, "APCS_STACKGUARD\t\t\tEQU\t0x%08X\n", APCS_STACKGUARD);
  }

  /* ADP definitions needed by the assembler code: */
  fprintf(outfile, "\n\t; ADP_Stopped reason codes:\n");
  fprintf(outfile, "ADP_Stopped_BranchThroughZero\t\tEQU\t%d\n",
          ADP_Stopped_BranchThroughZero);
  fprintf(outfile, "ADP_Stopped_UndefinedInstr\t\tEQU\t%d\n",
          ADP_Stopped_UndefinedInstr);
  fprintf(outfile, "ADP_Stopped_SoftwareInterrupt\t\tEQU\t%d\n",
          ADP_Stopped_SoftwareInterrupt);
  fprintf(outfile, "ADP_Stopped_PrefetchAbort\t\tEQU\t%d\n",
          ADP_Stopped_PrefetchAbort);
  fprintf(outfile, "ADP_Stopped_DataAbort\t\t\tEQU\t%d\n",
          ADP_Stopped_DataAbort);
  fprintf(outfile, "ADP_Stopped_AddressException\t\tEQU\t%d\n",
          ADP_Stopped_AddressException);
  fprintf(outfile, "ADP_Stopped_IRQ\t\t\t\tEQU\t%d\n", ADP_Stopped_IRQ);
  fprintf(outfile, "ADP_Stopped_FIQ\t\t\t\tEQU\t%d\n", ADP_Stopped_FIQ);
  fprintf(outfile, "ADP_Stopped_BreakPoint\t\t\tEQU\t%d\n",
          ADP_Stopped_BreakPoint);
  fprintf(outfile, "ADP_Stopped_RunTimeErrorUnknown\t\tEQU\t%d\n",
          ADP_Stopped_RunTimeErrorUnknown);
  fprintf(outfile, "ADP_Stopped_InternalError\t\tEQU\t%d\n",
          ADP_Stopped_InternalError);
  fprintf(outfile, "ADP_Stopped_UserInterruption\t\tEQU\t%d\n",
          ADP_Stopped_UserInterruption);
  fprintf(outfile, "ADP_Stopped_ApplicationExit\t\tEQU\t%d\n",
          ADP_Stopped_ApplicationExit);
  fprintf(outfile, "ADP_Stopped_StackOverflow\t\tEQU\t%d\n",
          ADP_Stopped_StackOverflow);
  fprintf(outfile, "ADP_Stopped_DivisionByZero\t\tEQU\t%d\n",
          ADP_Stopped_DivisionByZero);

  fprintf(outfile, "\n\t; ADP_Stopped_RunTimeError sub-codes:\n");
  fprintf(outfile, "\n\t; ADP_Stopped_InternalError sub-codes:\n");

  /* Misc ADP things: */
  fprintf(outfile, "\n\t; Misc ADP things:\n");
  fprintf(outfile, "ADP_HandleUnknown\t\tEQU\t0x%08X\n", ADP_HandleUnknown);
  fprintf(outfile, "ADP_CPUmode_Current\t\tEQU\t0x%08X\n",
          ADP_CPUmode_Current);
  fprintf(outfile, "ADP_CPUread_PCmode\t\tEQU\t0x%08X\n", ADP_CPUread_PCmode);
  fprintf(outfile, "ADP_CPUread_CPSR\t\tEQU\t0x%08X\n", ADP_CPUread_CPSR);
  fprintf(outfile, "ADP_CPUread_32bitIRQ\t\tEQU\t0x%08X\n",
          ADP_CPUread_32bitIRQ);
  fprintf(outfile, "ADP_CPUread_32bitUndef\t\tEQU\t0x%08X\n",
          ADP_CPUread_32bitUndef);
  fprintf(outfile, "ADP_CPUread_32bitSVC\t\tEQU\t0x%08X\n",
          ADP_CPUread_32bitSVC);
  fprintf(outfile, "ADP_CPU_LE\t\t\tEQU\t0x%08X\n", ADP_CPU_LE);
  fprintf(outfile, "ADP_CPU_BE\t\t\tEQU\t0x%08X\n", ADP_CPU_BE);
  fprintf(outfile, "ADP_CPU_BigEndian\t\tEQU\t0x%08X\n", ADP_CPU_BigEndian);

  /* Target specific definitions: */
  fprintf(outfile, "\n\t; Target specific definitions for PID:\n");
  fprintf(outfile, "ROMBase\t\t\tEQU\t0x%08X\n", ROMBase);
  fprintf(outfile, "ROMTop\t\t\tEQU\t0x%08X\n", ROMTop);

  fprintf(outfile, "DRAMBase\t\t\tEQU\t0x%08X\n", DRAMBase);
  fprintf(outfile, "DRAMTop\t\t\tEQU\t0x%08X\n", DRAMMax);

  fprintf(outfile, "SSRAMBase\t\t\tEQU\t0x%08X\n", SSRAMBase);
  fprintf(outfile, "SSRAMTop\t\t\tEQU\t0x%08X\n", SSRAMTop);

  /* interrupt handling options */
  fprintf(outfile, "HANDLE_INTERRUPTS_ON_IRQ\tEQU\t%d\n", HANDLE_INTERRUPTS_ON_IRQ);
  fprintf(outfile, "HANDLE_INTERRUPTS_ON_FIQ\tEQU\t%d\n", HANDLE_INTERRUPTS_ON_FIQ);

#ifdef Angel_ApplHeap
  fprintf(outfile, "Angel_ApplHeap\t\tEQU\t0x%08X\n", Angel_ApplHeap);
#endif
#ifdef Angel_ApplHeapLimit
  fprintf(outfile, "Angel_ApplHeapLimit\tEQU\t0x%08X\n",
          Angel_ApplHeapLimit);
#endif
  fprintf(outfile, "Angel_ApplStackOffset\t\tEQU\t0x%08X\n", Angel_ApplStackOffset);
  fprintf(outfile, "Angel_ApplStackLimitOffset\tEQU\t0x%08X\n", Angel_ApplStackLimitOffset);
  fprintf(outfile, "Angel_SVCStackOffset\t\tEQU\t0x%08X\n", Angel_SVCStackOffset);
  fprintf(outfile, "Angel_SVCStackLimitOffset\t\tEQU\t0x%08X\n", Angel_SVCStackLimitOffset);

  fprintf(outfile, "Angel_IRQStackSize\t\tEQU\t0x%08X\n", Angel_IRQStackSize);
  fprintf(outfile, "Angel_IRQStackOffset\t\tEQU\t0x%08X\n", Angel_IRQStackOffset);
  fprintf(outfile, "Angel_IRQStackLimitOffset\t\tEQU\t0x%08X\n", Angel_IRQStackLimitOffset);
  fprintf(outfile, "Angel_FIQStackOffset\t\tEQU\t0x%08X\n", Angel_FIQStackOffset);
  fprintf(outfile, "Angel_FIQStackLimitOffset\t\tEQU\t0x%08X\n", Angel_FIQStackLimitOffset);
  fprintf(outfile, "Angel_UNDStackOffset\t\tEQU\t0x%08X\n", Angel_UNDStackOffset);
  fprintf(outfile, "Angel_UNDStackLimitOffset\t\tEQU\t0x%08X\n", Angel_UNDStackLimitOffset);
  fprintf(outfile, "Angel_ABTStackOffset\t\tEQU\t0x%08X\n", Angel_ABTStackOffset);
  fprintf(outfile, "Angel_ABTStackLimitOffset\t\tEQU\t0x%08X\n", Angel_ABTStackLimitOffset);
  fprintf(outfile, "Angel_AngelStackOffset\t\tEQU\t0x%08X\n", Angel_AngelStackOffset);
  fprintf(outfile, "Angel_AngelStackLimitOffset\t\tEQU\t0x%08X\n", Angel_AngelStackLimitOffset);
  fprintf(outfile, "Angel_SVCStackSize\t\tEQU\t0x%08X\n", Angel_SVCStackSize);

  /* a selection of target specific I/O addresses */
  fprintf(outfile, "RPCBASE\t\t\tEQU\t0x%08X\n", RPCBASE);
  fprintf(outfile, "ClearResetMap\t\tEQU\t0x%08X\n", ClearResetMap);
  fprintf(outfile, "ICBASE\t\t\tEQU\t0x%08x\n", ICBASE);
  fprintf(outfile, "IRQStatus\t\tEQU\t0x%08X\n", IRQStatus);
  fprintf(outfile, "IRQEnableClear\t\tEQU\t0x%08X\n", IRQEnableClear);
  fprintf(outfile, "FIQEnableClear\t\tEQU\t0x%08X\n", FIQEnableClear);
  fprintf(outfile, "FIQStatus\t\tEQU\t0x%08X\n", FIQStatus);
  fprintf(outfile, "IRQ_SERIALA\t\tEQU\t0x%08X\n", IRQ_SERIALA);
  fprintf(outfile, "IRQ_SERIALB\t\tEQU\t0x%08X\n", IRQ_SERIALB);
  fprintf(outfile, "IRQ_CARDA\t\tEQU\t0x%08X\n", IRQ_CARDA);
  fprintf(outfile, "IRQ_CARDB\t\tEQU\t0x%08X\n", IRQ_CARDB);
  fprintf(outfile, "IRQ_PARALLEL\t\tEQU\t0x%08X\n", IRQ_PARALLEL);
  fprintf(outfile, "IRQ_TIMER1\t\tEQU\t0x%08X\n", IRQ_TIMER1);
  fprintf(outfile, "IRQ_TIMER2\t\tEQU\t0x%08X\n", IRQ_TIMER2);

  /* Device driver variables, set at compile time */
  fprintf(outfile, "\n\t; Definitions for device drivers.\n\n");
  fprintf(outfile, "PARALLEL_SUPPORTED\tEQU\t%d\n", PARALLEL_SUPPORTED);
  fprintf(outfile, "PROFILE_SUPPORTED\tEQU\t%d\n", PROFILE_SUPPORTED);
  fprintf(outfile, "PCMCIA_SUPPORTED\tEQU\t%d\n", PCMCIA_SUPPORTED);
  fprintf(outfile, "CACHE_SUPPORTED\tEQU\t%d\n", CACHE_SUPPORTED);
  fprintf(outfile, "ST16C552_NUM_PORTS\tEQU\t%d\n\n", ST16C552_NUM_PORTS);
  fprintf(outfile, "SERIAL_INTERRUPTS_ON_FIQ\tEQU\t%d\n", SERIAL_INTERRUPTS_ON_FIQ);
  fprintf(outfile, "SYSCLOCK\t\tEQU\t%d\n", SYSCLOCK);

  fprintf(outfile, "IH_ST16C552_A\t\tEQU\t%d\n", IH_ST16C552_A);
#if (ST16C552_NUM_PORTS > 1) || (defined(LOGTERM_DEBUGGING) && (LOGTERM_DEBUGGING > 0))
  fprintf(outfile, "IH_ST16C552_B\t\tEQU\t%d\n", IH_ST16C552_B);
#endif
#if PARALLEL_SUPPORTED
  fprintf(outfile, "IH_PARALLEL\t\tEQU\t%d\n", IH_PARALLEL);
#endif
#if PCMCIA_SUPPORTED
  fprintf(outfile, "IH_PCMCIA_A\t\tEQU\t%d\n", IH_PCMCIA_A);
  fprintf(outfile, "IH_PCMCIA_B\t\tEQU\t%d\n", IH_PCMCIA_B);
#endif
#if PROFILE_SUPPORTED
  fprintf(outfile, "IH_PROFILETIMER\t\tEQU\t%d\n", IH_PROFILETIMER);
#endif
  fprintf(outfile, "DE_NUM_INT_HANDLERS\tEQU\t%d\n", DE_NUM_INT_HANDLERS);
  fprintf(outfile, "DC_SET_LED\t\tEQU\t%d\n", DC_SET_LED);
  fprintf(outfile, "DI_LED_DEVICE\t\tEQU\t%d\n", DI_LED_DEVICE);

  /* Terminate the file cleanly */
  fprintf(outfile, "\n\tOPT\t(old_opt)\n");
  fprintf(outfile, "\tEND\t; EOF lolevel_s\n");

  return(0);
}

/* EOF makelo.c */
